06链表
      // 9m
      // LRU缓存淘汰算法
        // 常识
          FIFO
          LFU
          LRU
          
        // 思路
          // 有序单链表, 尾部为较早访问
          // 新数据被访问, 从链表头开始遍历
          // 已缓存
            // 删除结点
            // 插入链表部
          // 未缓存
            // 缓存未满, 直接插入头部
            // 缓存已满
              // 删除尾结点
              // 插入链表头部
        // 目前复杂度是O(n)

      // 单链表
        // data
          // next
        // 头结点
          // 基地址
        // 尾结点
          // nil
          // NULL
        // 性能
          // 插入O(1)
          // 查寻O(n)
      // 循环链表

        // 尾结点指向头结点

      // 双向链表
        // prev
          // data
            // next
        // O(1) 时间复杂度找到前驱结点
        // 删除
          // 删除值等于给定值结点
            // 遍历对比
            // O(n)
          // 删除给定指针指向结点
            // 单链重头遍历
            // 双链直接删
        // 插入
          // 给点节点前插入方便
        // 按值查询
          // 有序链表
          // 记录上次查找的位置 p
          // 根据要查找的值与p的大小关系，决定是往前还是往后查找
        // LinkedHashMap

      // 双向循环链表
      
      // 性能对比
        // 数组使用连续内存,可以借助CPU缓存机制预读数据
        // 数组占用整块连续内存, 且搬运耗时
        // 链表内存消耗稍大, 频繁使用容易内存碎片

      // 技巧
        // 指针或引用
// 类的属性?

// 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针

// 根据环境理解具体的值,还是xx地址

p->next=q
// p 结点中的 next 指针存储了 q 结点的内存地址

p->next=p->next->next
// p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址


        // 指针丢失及内存泄漏
// p->next = x;  // 将 p 的 next 指针指向 x 结点；
// x->next = p->next;  // 将 x 的结点的 next 指针指向 b 结点；

// 将x 赋值给p的指针的时候, 之前的信息就丢失了
x->next = p->next;
p->next = x;

        // 哨兵
// p, new_node
new_node->next = p->next;
p.next = new_node;

// 如果是空链
if (p->next == null){
  p->next = new_node 
} else {
  new_node->next = p->next;
p.next = new_node;
}

// p->next = NULL // 成打断了
p->next = p->next->next;

if (head->next == null){
  p->next == null;
}


  // 单链表的首尾逻辑和其他部分不一样
  // 带头链表
      // 哨兵节点不存储数据,一直存在
         // 很多代码实现比如插入排序、归并排序、动态规划等 都有用到

        // 留意边界
        // 画图
        // 多练习
      // 代码模块
        // 快慢
        // 翻转
        // 列表读值再处理
      // leetcode
        // 234
        // 206
        // 141
        // 142
        // 21
        // 23
        // 24
        // 25
        // 19
        // 876
      // 问题及答案
        // 实现单链表、循环链表、双向链表，支持增删操作
        // 实现单链表反转
        // 实现两个有序的链表合并为一个有序链表
        // 实现求链表的中间结点
        // 用数组实现LRU
          // 数组模拟链表
          // 目标移数组尾,其后左移,满删除首部
          // 循环使用, 标记旧的, 插入下一位置,满则清
          // 大数组, 不清除,不停扩充,
        // 判断链表回文题234
// 用额外数组解决了
// 时间O(n),空间O(n)

        // 哨兵简化编码场景    
